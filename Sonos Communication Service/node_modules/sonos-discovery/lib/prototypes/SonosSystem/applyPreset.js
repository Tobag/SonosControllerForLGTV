'use strict';

var logger = require('../../helpers/logger');

function setVolume(system, playerPresets) {
  var initialPromise = Promise.resolve();
  var players = [];

  return playerPresets.reduce(function (promise, playerInfo) {
    var player = system.getPlayer(playerInfo.roomName);
    if (!player) {
      return promise;
    }

    return promise.then(function () {
      players.push(player);
      if (playerInfo.hasOwnProperty('volume')) {
        logger.debug('setting volume ' + playerInfo.volume + ' on ' + player.roomName);
        return player.setVolume(playerInfo.volume);
      }
    });
  }, initialPromise).then(function () {
    return players;
  });
}

function pauseOthers(system) {
  var initialPromise = Promise.resolve();
  return system.zones.reduce(function (promise, zone) {
    return promise.then(function () {
      logger.debug('pausing ' + zone.coordinator.roomName);
      return zone.coordinator.pause().catch(function (err) {});
    });
  }, initialPromise);
}

function groupWithCoordinator(players) {
  var initialPromise = Promise.resolve();
  var coordinator = players[0];
  var groupingUri = 'x-rincon:' + coordinator.uuid;

  // Skip first player since it is coordinator
  return players.slice(1).reduce(function (promise, player) {

    if (player.avTransportUri === groupingUri) {
      logger.debug('skipping grouping for ' + player.roomName + ' because it is already grouped with coordinator');
      return promise;
    }

    logger.debug('adding ' + player.roomName + ' to coordinator ' + coordinator.roomName);
    return promise.then(function () {
      return player.setAVTransport(groupingUri);
    });
  }, initialPromise);
}

function ungroupFromCoordinator(system, players) {
  // Find zone
  var coordinator = players[0];
  var zone = system.zones.find(function (x) {
    return x.uuid === coordinator.uuid;
  });

  var playerNames = players.map(function (player) {
    return player.roomName;
  });
  var superfluousPlayers = zone.members.filter(function (member) {
    return playerNames.indexOf(member.roomName) === -1;
  });

  return superfluousPlayers.reduce(function (promise, player) {
    logger.debug('ungrouping ' + player.roomName + ' from coordinator ' + coordinator.roomName);
    return promise.then(function () {
      return player.becomeCoordinatorOfStandaloneGroup();
    });
  }, Promise.resolve());
}

function applyPreset(preset) {
  var _this = this;

  var promise = Promise.resolve();
  var players = void 0;
  var coordinator = void 0;

  if (preset.pauseOthers) {
    promise = promise.then(function () {
      return pauseOthers(_this);
    });
  }

  promise = promise.then(function () {
    players = preset.players.map(function (playerInfo) {
      return _this.getPlayer(playerInfo.roomName);
    });
  });

  promise = promise.then(function () {
    // store coordinator for future use
    coordinator = players[0];
    logger.debug('coordinator is ' + coordinator.roomName);

    // If the first player needs to be broken out, do that before we group the other players with it.
    if (preset.players.length === 1 || coordinator.coordinator.uuid !== coordinator.uuid) {
      logger.debug('breaking out ' + coordinator.roomName);
      return coordinator.becomeCoordinatorOfStandaloneGroup().then(function () {
        return groupWithCoordinator(players);
      });
    }

    return groupWithCoordinator(players).then(function () {
      // This only needs to happen if we didn't ungroup the coordinator
      return ungroupFromCoordinator(_this, players);
    });
  });

  promise = promise.then(function () {
    return setVolume(_this, preset.players);
  });

  if (preset.favorite) {
    promise = promise.then(function () {
      return coordinator.replaceWithFavorite(preset.favorite);
    });
  } else if (preset.playlist) {
    promise = promise.then(function () {
      return coordinator.replaceWithPlaylist(preset.playlist);
    });
  } else if (preset.uri) {
    promise = promise.then(function () {
      return coordinator.setAVTransport(preset.uri, preset.metadata);
    });
  }

  if (preset.playMode) {
    promise = promise.then(function () {
      return coordinator.setPlayMode(preset.playMode);
    });
  }

  if (preset.trackNo) {
    promise = promise.then(function () {
      return coordinator.trackSeek(preset.trackNo);
    });
  }

  if (preset.elapsedTime) {
    promise = promise.then(function () {
      return coordinator.timeSeek(preset.elapsedTime);
    });
  }

  if (preset.sleep) {
    promise = promise.then(function () {
      return coordinator.sleep(preset.sleep);
    });
  }

  if (!preset.state || preset.state.toLowerCase() === 'playing') {
    promise = promise.then(function () {
      return coordinator.play();
    });
  }

  return promise;
}

module.exports = applyPreset;