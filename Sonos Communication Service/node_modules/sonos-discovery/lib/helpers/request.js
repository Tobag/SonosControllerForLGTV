'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var http = require('http');
var url = require('url');

function request(options) {
  // Store a stack trace in case we get an error status code
  var stackHolder = {};
  Error.captureStackTrace(stackHolder, request);

  return new Promise(function (resolve, reject) {
    var uri = url.parse(options.uri);

    var requestOptions = {
      method: options.method || 'GET',
      path: uri.path,
      host: uri.hostname,
      port: uri.port * 1 || 80
    };

    if (options.headers) {
      requestOptions.headers = options.headers;
    }

    var client = http.request(requestOptions, function (res) {
      if (res.statusCode < 200 || res.statusCode > 299) {
        var error = new RequestError(requestOptions, res);
        error.stack = stackHolder.stack;
        return reject(error);
      }

      if (options.stream) {
        resolve(res);
        return;
      }

      var buffer = [];

      res.on('data', function (chunk) {
        buffer.push(chunk);
      });

      res.on('end', function () {
        resolve(buffer.join(''));
      });
    });

    client.on('error', function (e) {
      reject(e);
    });

    client.on('timeout', function () {
      var error = new Error('http request timed out');
      error.stack = stackHolder.stack;
      reject(error);
    });

    if (options.timeout) {
      client.setTimeout(options.timeout);
    }

    if (options.body) {
      client.write(options.body);
    }

    client.end();
  });
}

var RequestError = function (_Error) {
  _inherits(RequestError, _Error);

  function RequestError(options, res) {
    _classCallCheck(this, RequestError);

    var msg = 'Got status ' + res.statusCode + ' when invoking ' + options.path;

    var _this = _possibleConstructorReturn(this, (RequestError.__proto__ || Object.getPrototypeOf(RequestError)).call(this, msg));

    Object.assign(_this, options);
    _this.statusCode = res.statusCode;
    return _this;
  }

  return RequestError;
}(Error);

module.exports = request;