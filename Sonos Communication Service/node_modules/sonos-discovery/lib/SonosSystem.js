'use strict';

var ssdp = require('./sonos-ssdp');
var request = require('./helpers/request');
var NotificationListener = require('./NotificationListener');
var Player = require('./models/Player');
var Sub = require('./models/Sub');
var Subscriber = require('./Subscriber');
var EventEmitter = require('events').EventEmitter;
var util = require('util');
var path = require('path');
var requireDir = require('./helpers/require-dir');
var soap = require('./helpers/soap');
var parseServices = require('./helpers/parse-services');
var UnknownServiceError = require('./errors/unknown-service');

function isVisible(member) {
  // If a member has the attribute invisible == 1, it is either a
  // BRIDGE, BOOST, SUB or a right channel stereo pair
  if (Array.isArray(member)) {
    return member.some(function (x) {
      return x.invisible !== '1';
    });
  }

  return member.invisible !== '1';
}

function SonosSystem() {

  var _this = this;
  _this.localEndpoint = '0.0.0.0';
  _this.players = [];
  _this.zones = [];
  _this.availableServices = {};
  var listener = void 0;
  var playerCache = {};
  var subCache = {};

  function queueChange(uuid) {
    var player = _this.getPlayerByUUID(uuid);
    if (player && player.uuid) {
      _this.emit('queue-change', player);
    }
  }

  function listChange(type) {
    _this.emit('list-change', type);
  }

  function tryGet(cache, Type, member) {
    if (cache[member.uuid]) {
      return cache[member.uuid];
    }

    cache[member.uuid] = new Type(member, listener, _this);
    return cache[member.uuid];
  }

  function getPlayers(members) {
    if (members instanceof Array === false) {
      // single item
      return [tryGet(playerCache, Player, members)];
    }

    // Find normal players
    var players = members.filter(function (member) {
      return isVisible(member);
    }).map(function (member) {
      return tryGet(playerCache, Player, member);
    });

    // fix sub and pairs
    members.filter(function (member) {
      return !isVisible(member);
    }).forEach(function (member) {
      var channelMap = /^(\w+):([\w,]{5});(\w+):([\w,]{5})$/.exec(member.channelmapset);
      if (!channelMap) {
        return;
      }

      var primaryUuid = channelMap[1];
      var isSub = channelMap[4] === 'SW,SW';

      if (isSub) {
        playerCache[primaryUuid].sub = tryGet(subCache, Sub, member);
      }
    });

    return players;
  }

  function topologyChange(uuid, topology) {
    var players = [];

    var zones = topology.filter(function (zone) {
      return isVisible(zone.zonegroupmember);
    }).map(function (zone) {
      var members = getPlayers(zone.zonegroupmember);
      Array.prototype.push.apply(players, members);

      // fix coordinator for members
      var coordinator = playerCache[zone.$attrs.coordinator];
      members.forEach(function (member) {
        member.coordinator = coordinator;
      });

      return {
        coordinator: coordinator,
        members: members,
        uuid: zone.$attrs.coordinator,
        id: zone.$attrs.id
      };
    });

    _this.zones = zones;
    _this.players = players;

    _this.emit('topology-change', zones);

    // Update available services
    var anyPlayer = _this.getAnyPlayer();
    soap.invoke(anyPlayer.baseUrl + '/MusicServices/Control', soap.TYPE.ListAvailableServices).then(soap.parse).then(parseServices).then(function (availableServices) {
      if (!Object.keys(_this.availableServices).length) {
        setImmediate(function () {
          return _this.emit('initialized');
        });
      }

      _this.availableServices = availableServices;
    });
  }

  function init(info) {
    ssdp.stop();

    request({
      uri: info.location,
      method: 'GET',
      stream: true
    }).then(function (res) {
      _this.localEndpoint = res.socket.address().address;
      listener = new NotificationListener(_this.localEndpoint);
      listener.on('queue-change', queueChange);
      listener.on('list-change', listChange);
      listener.on('topology', topologyChange);
      listener.on('listening', function (port) {
        _this.subscriber = new Subscriber('http://' + info.ip + ':1400/ZoneGroupTopology/Event', listener.endpoint());
      });
    }).catch(function (e) {
      console.error(e);
    });
  }

  ssdp.start();
  ssdp.on('found', init);
}

// This needs to be before all prototype methods!
util.inherits(SonosSystem, EventEmitter);

SonosSystem.prototype.getPlayer = function getPlayer(name) {
  return this.players.find(function (player) {
    return player.roomName.toLowerCase() === name.toLowerCase();
  });
};

SonosSystem.prototype.getPlayerByUUID = function getPlayerByUUID(uuid) {
  return this.players.find(function (player) {
    return player.uuid === uuid;
  });
};

var playerIndex = 0;

SonosSystem.prototype.getAnyPlayer = function getAnyPlayer() {
  return this.players[playerIndex++ % this.players.length];
};

SonosSystem.prototype.dispose = function dispose() {
  if (this.subscriber && this.subscriber.dispose) this.subscriber.dispose();
  this.players.forEach(function (player) {
    if (player.sub && player.sub.dispose) player.sub.dispose();
    if (player.dispose) player.dispose();
  });
};

SonosSystem.prototype.getServiceId = function getServiceId(serviceName) {
  if (!this.availableServices[serviceName]) {
    throw new UnknownServiceError(serviceName);
  }

  return this.availableServices[serviceName].id;
};

SonosSystem.prototype.getServiceType = function getServiceType(serviceName) {
  if (!this.availableServices[serviceName]) {
    throw new UnknownServiceError(serviceName);
  }

  return this.availableServices[serviceName].type;
};

requireDir(path.join(__dirname, '/prototypes/SonosSystem'), function (proto) {
  SonosSystem.prototype[proto.name] = proto;
});

module.exports = SonosSystem;