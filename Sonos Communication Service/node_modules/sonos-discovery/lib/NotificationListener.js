'use strict';

var http = require('http');
var EventEmitter = require('events').EventEmitter;
var util = require('util');
var flow = require('xml-flow');
var Readable = require('stream').Readable;
var logger = require('./helpers/logger');

var LIST_TYPE = require('./types/list-type');
var lastUpdate = {};

function createStream(str) {
  var stream = new Readable();
  stream._read = function noop() {};

  stream.push(str);
  stream.push(null);
  return stream;
}

function parseTopology(text) {
  return new Promise(function (resolve, reject) {

    var sax = flow(createStream(text), {
      preserveMarkup: flow.NEVER,
      useArrays: flow.SOMETIMES
    });

    var zoneGroups = [];

    sax.on('tag:zonegroup', function (group) {
      if (Array.isArray(group.zonegroupmember)) {
        group.zonegroupmember = group.zonegroupmember.map(function (member) {
          return member.$attrs || member;
        });
      } else if (group.zonegroupmember.$attrs) {
        group.zonegroupmember = group.zonegroupmember.$attrs;
      }

      zoneGroups.push(group);
    });

    sax.on('end', function () {
      resolve(zoneGroups);
    });

    sax.on('error', function (e) {
      reject(e);
    });
  });
}

function parseLastChange(text) {
  return new Promise(function (resolve, reject) {

    var sax = flow(createStream(text));

    sax.on('tag:instanceid', function (lastChange) {
      resolve(lastChange);
    });

    sax.on('error', function (e) {
      reject(e);
    });
  });
}

function NotificationListener(localEndpoint) {
  var _this = this;
  var server = void 0;
  var listeningPort = 3500;

  this.endpoint = function () {
    return 'http://' + localEndpoint + ':' + listeningPort + '/';
  };

  function init() {
    server = http.createServer(notificationHandler);
    server.listen(listeningPort);

    server.on('listening', function () {
      _this.emit('listening', listeningPort);
    });

    server.on('error', function (e) {
      if (e.code === 'EADDRINUSE') {
        server.listen(++listeningPort);
      }
    });
  }

  function notificationHandler(req, res) {
    req.on('end', function () {
      res.writeHead(200, 'OK');
      res.end();
    });

    if (req.method !== 'NOTIFY' || !req.headers || !req.headers.sid) {
      res.end();
      return;
    }

    var matches = req.headers.sid.match(/uuid:(.+)_sub/);

    if (!matches) {
      return;
    }

    var uuid = matches[1];

    var sax = flow(req, { useArrays: flow.NEVER });

    sax.on('tag:zonegroupstate', function (property) {
      logger.trace(property.$text);
      parseTopology(property.$text).then(function (topology) {
        _this.emit('topology', uuid, topology);
      });
    });

    sax.on('tag:lastchange', function (property) {
      logger.trace(property.$text);
      parseLastChange(property.$text).then(function (lastChange) {
        _this.emit('last-change', uuid, lastChange);
      });
    });

    sax.on('tag:groupmute', function (property) {
      logger.trace(property.$text);
      _this.emit('group-mute', uuid, property.$text);
    });

    sax.on('tag:savedqueuesupdateid', function (property) {
      logger.trace('tag:savedqueuesupdateid', property.$text);
      if (lastUpdate[LIST_TYPE.SAVED_QUEUES] !== property.$text) {
        lastUpdate[LIST_TYPE.SAVED_QUEUES] = property.$text;
        _this.emit('list-change', LIST_TYPE.SAVED_QUEUES);
      }
    });

    sax.on('tag:favoritesupdateid', function (property) {
      logger.trace('tag:favoritesupdateid', property.$text);
      if (lastUpdate[LIST_TYPE.FAVORITES] !== property.$text) {
        lastUpdate[LIST_TYPE.FAVORITES] = property.$text;
        _this.emit('list-change', LIST_TYPE.FAVORITES);
      }
    });

    sax.on('tag:containerupdateids', function (property) {
      logger.trace('tag:containerupdateids', property.$text);
      if (property.$text && property.$text.indexOf('Q:0') !== -1) {
        _this.emit('queue-change', uuid);
      }

      if (property.$text && property.$text.indexOf('AI:') !== -1) {
        _this.emit('list-change', LIST_TYPE.INPUTS);
      }
    });
  }

  init();
}

util.inherits(NotificationListener, EventEmitter);

module.exports = NotificationListener;